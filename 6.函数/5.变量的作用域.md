# 变量的作用域

Python的作用域有4种：

- L （Local） 局部作用域
- E （Enclosing） 闭包函数外的函数中
- G （Global） 全局作用域
- B （Built-in） 内建作用域

以 **L –> E –> G –>B** 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。

举个例子：

```python
a = list(range(10))
print(id(a), a)

def show():
    a = list(range(3))
    print(id(a), a)
    
def print_list():
    print(id(a), a)

def update(arr: list):
    arr *= 3
    print(id(arr), arr)

show()
print_list()
update(a)
print(id(a), a)
```

其结果为：

```
140192172597056 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
140192172638272 [0, 1, 2]
140192172597056 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
140192172597056 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
140192172597056 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

可以发现，show()中定义了a，这是局部的变量，而在其外面也有一个a，这是全局变量，因为局部作用域里可以找到a，所以使用局部作用域中的a。

update()传入参数为list类型的arr，通过打印变量的内存地址可以发现，传参传的是引用，对参数的修改会直接影响全局变量a。

> 如果传入参数是数字的话就不会这样，即使是传入参数，修改了之后其内存地址是会变的，不会影响外面的数据。
>
> 这是因为列表是可变对象，而数字、字符串、元组都是不可变对象，**当赋值的是可变对象时候，对其中一个变量的值改变，另外一个变量的值也会改变。它们的内存地址始终一样不会变**;**当赋值的是不可变对象时候，对其中一个变量的改变，另一个变量的值内存地址不会改变，而改变的变量相当于赋了一个新的对象(内存地址)。**
>
> 当然，可以用global关键字声明一个变量是全局变量。