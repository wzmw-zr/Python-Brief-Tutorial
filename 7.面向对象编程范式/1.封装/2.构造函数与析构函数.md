# 类的构造函数与析构函数

## 一、类的构造函数

类的构造和初始化涉及两个函数`__new__()`,`__init__()`。

我们定义一个类，并生成初始化`__init__（） `函数和`__new__（）`函数：

```python
class A(object):
    def __init__(self,*args, **kwargs):
        print("init", self.__init__)
    def __new__(cls,*args, **kwargs):
        print("new", self.__new__)
        return object.__new__(cls, *args, **kwargs)

a = A()
```

输出结果：

```python
new <class '__main__.A'>
init <class '__main__.A'>
```

可以看出，当实例化A类的时候，`__new__`方法首先被调用，然后是`__init__`方法。

一般来说，`__new__`和`__init__`函数都会有下面的形式：

```python
def __init__(self, *args, **kwargs):
    # func_suite

# 这里的cls是默认的参数，表示当前类的类型
def __new__(cls, *args, **kwargs):
    # func_suite
return obj
```

- `__new__`方法是Python中真正的构造方法(创建并返回实例)，通过这个方法可以产生一个`cls`对应的实例对象，因此`__new__`方法一定要有返回。
- `__init__`方法是一个初始化的方法，`self`代表由类产生出来的实例对象，即`__new__`返回的实例，`__init__`将对这个对象进行相应的初始化操作。

### 1.`__new__`的特性

`__ new__`是在新式类中新出现的方法，它有以下行为特性：

- `__new__` 方法是在类实例化对象时**第一个调用的方法，将返回实例对象**。
- `__new__` 方法始终都是**类方法（即第一个参数为cls）**，即使没有被加上装饰器。
- 第一个参数cls是**当前正在实例化的类**，如果要得到当前类的实例，应当在当前类中的`__new__`方法语句中调用当前类的父类的`__new__`方法。

**如果当前类是直接继承自 object，那当前类的 `__new__`方法返回的对象应该为：**

```python
def __new__(cls, *args, **kwargs):
    # func_suite
return object.__new__(cls, *args, **kwargs)
```

以`object.__new__(cls[,...])`为例进一步讲解`__new__`：

+ 调用以创建一个 *cls* 类的新实例。

+ `__new__()`是一个静态方法 (因为是特例所以你**通常不需要显式地声明**)，它会将所请求实例所属的类作为第一个参数。其余的参数会被传递给对象构造器表达式 (对类的调用)。

+ `__new__()`的返回值应为新对象实例 (通常是 *cls* 的实例)。

  > 典型的实现会附带适宜的参数使用 `super().__new__(cls[, ...])`，通过超类的 `__new__()`方法来创建一个类的新实例，然后根据需要修改新创建的实例再将其返回。

+ 如果 `__new__()` 在构造对象期间被发起调用并且它返回了一个实例或 *cls* 的子类，则新实例的 `__init__()`方法将以 `__init__(self[, ...])` 的形式被发起调用，其中 *self* 为新实例而其余的参数与被传给对象构造器的参数相同。如果 `__new__()`未返回一个 *cls* 的实例，则新实例的 `__init__()`方法就不会被执行。

+ `__new__()`的目的主要是允许不可变类型的子类 (例如 int, str 或 tuple) 定制实例创建过程。它也常会在自定义元类中被重载以便定制类创建过程。

> `__new__`决定是否要使用该类的`__init__`方法，因为`__new__`可以调用其他类的构造方法或者直接返回别的类创建的对象来作为本类的实例。

### 2.`__init__ `的特性

1. 在实例 (通过`__new__()`) 被创建之后，返回调用者之前调用。其参数与传递给类构造器表达式的参数相同。
2. 一个基类如果有 `__init__()`方法，则其所派生的类如果也有 `__init__()`方法，就必须显式地调用它以确保实例基类部分的正确初始化。例如: `super().__init__([args...])`.因为对象是由 `__new__()`和 `__init__()`协作构造完成的 (由 `__new__()`创建，并由 `__init__()`定制)，所以 `__init__()`返回的值只能是 `None`。



## 二、类的析构函数

类的析构函数是`__del__()`，在我们显式调用`del`语句或者脱离了实例所属的作用域的时候就会调用`__del__()`，回收资源。

 如果一个基类具有`__del__()`方法，则其所派生的类如果也有`__del__()`方法，就必须显式地调用它以确保实例基类部分的正确清除。